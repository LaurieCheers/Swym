<html>
<style type="text/css">
body{
font-family: Verdana, Arial, Helvetica;
font-size: 10pt;
background-color: #fcffff;
margin: 10px 40px 10px 40px;
}
table{
font-family: Verdana, Arial, Helvetica;
font-size: 10pt;
}
textarea{
background-color: #FAEFE8;
border-style: solid;
border-width: 1;
border-color: #AAAAAA;
}
textarea.outputarea{
background-color: #CCCCCC;
}
code{
color: #0044AA;
font-style: normal;
}
div.demo{
background-color: #F0F0F0;
padding: 10px 10px 5px 10px;
max-width: 690;
clear:right;
}
div.aside{
font-size: 9pt;
font-style: italic;
padding: 0px 0px 0px 20px;
}
div.floatbox{
float:right;
padding: 10px 10px 10px 10px;
}
div.control{
float:right;
vertical-align: top;
}
tr.odd{
background-color: #F0F0F0;
}
</style>
<head><title>Swym - an interactive tutorial</title></head>
<script language=javascript src="swym.js"></script>
<script language=javascript src="swymTokenize.js"></script>
<script language=javascript src="swymParser.js"></script>
<script language=javascript src="swymEtc.js"></script>
<script language=javascript src="swymRuntime.js"></script>
<script language=javascript src="swymCompile.js"></script>
<script language=javascript src="swymTypeCheck.js"></script>
<script language=javascript src="swymStdlyb.js"></script>
<script language=javascript>
function getTextfields(div)
{
var sourceText;
var destText;

for( var Idx = 0; Idx < div.childNodes.length; Idx++ )
{
var nodeI = div.childNodes[Idx];
if ( nodeI && nodeI.type == "textarea" )
{
if ( !sourceText )
{
sourceText = nodeI;
}
else
{
destText = nodeI;
break;
}
}
}

return {source:sourceText, dest:destText};
}

function saveOriginal(textArea)
{
if ( !textArea.originalValue )
textArea.originalValue = textArea.value;
}

function doRevert(div)
{
var fields = getTextfields(div);

if ( fields.source.originalValue )
fields.source.value = fields.source.originalValue;
fields.dest.value = "";
}

function doResize(div)
{
var fields = getTextfields(div.parentNode);

if ( fields.source.savedrows && fields.source.rows != fields.source.savedrows )
{
fields.source.rows = fields.source.savedrows;
fields.dest.rows = fields.dest.savedrows;
fields.source.cols = fields.source.savedcols;
fields.dest.cols = fields.dest.savedcols;
}
else
{
fields.source.savedrows = fields.source.rows;
fields.dest.savedrows = fields.dest.rows;
fields.source.savedcols = fields.source.cols;
fields.dest.savedcols = fields.dest.cols;
fields.source.rows = 20;
fields.dest.rows = 20;
fields.source.cols = 80;
fields.dest.cols = 80;
}
}

function runDemo(div)
{
//var theDiv = document.getElementById(divId);
var fields = getTextfields(div);

fields.dest.value = "...waiting...";

// call out to the main "eval" method
var result = SWYM.Eval(fields.source.value);

fields.dest.value = result;
}
</script>
<body>
<image align=top src="SwymLogo1.png">
<p><i>A language tutorial by Laurie Cheers.</i></p>
<p>Welcome to Swym. This programming language is designed to let you Say What You Mean, as clearly and elegantly as possible. (It's pronounced "swim", in case you were wondering.)</p>

<p>I designed Swym in a crazy way - I wrote down some programs I wanted to be able to write, regardless of whether they were implementable; and then I reverse-engineered semantics for them. That process showed me how I needed to change the programs, to make them behave more consistently, and to make them parseable. It took about five years of iterating like this, on and off, before the language finally started to gel enough to be implementable. I hope you like the results. If nothing else, the process seems to have given Swym a unique flavour.</p>

<p>The interpreter is currently implemented in Javascript. This isn't intended to be permanent - just for this proof-of-concept implementation. For the same reason, don't be surprised if you experience any slowdowns: at the moment this language isn't optimized at all. Seriously; not. at. all. I decided I preferred getting it working over getting it fast.</p>

<p>I wrote it in Javascript partly because I wanted to learn Javascript better, but mostly to let me embed a command line in this webpage, like this...</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
"Hello, Quine!"</textarea>
<div class=control>
<input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'>
</div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Click <b>Run</b> to see the output. (You'll need Javascript enabled on your browser, of course.)</p>
<p>Each time you click you're running the Swym interpreter, live in your web browser. Feel free to rewrite any of the examples on this page and run them to see what you get.</p>

<p>You can also click the <b>+/-</b> button to expand the text boxes, or click <b>Revert</b> if you've deleted the original text and want to get it back.

<hr><h3>Contents</h3>
<ol>
<li><a href="#BasicsSection">The Basics</a></li>
<li><a href="#ArraysSection">Arrays</a></li>
<li><a href="#StringsSection">Strings</a></li>
<li><a href="#FunctionsSection">Functions and Blocks</a></li>
<li><a href="#MultivalueSection">Multi-values</a></li>
<!--li><a href="#Section5">Variables and cells</a></li-->
<li><a href="#EtcSection">Etc</a></li>
<li><a href="#PatternsSection">Patterns and lazy lists</a></li>
<li><a href="#FutureSection">Future development</a></li>
</ol>

<p>But hey, maybe you're in a hurry, and you just want to get a flavour of what the language is like. Well, here's a little buffet of code examples. Read on for full details...</p>

<p>Non-intimidating functional programming style:</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
// BTW this is a terrible algorithm for detecting prime numbers
Int.'divisors' = [1..this].where{this%it == 0}
Int.'isPrime' = .divisors == [1,this]

[1..100].where{.isPrime}
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Multi-values:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[10, 1..4, 0, 100, 1<..<8]</textarea>
<div class=control>
<input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'>
</div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>The etc keyword:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Array.'addUp' = .1st + .2nd + etc;

[1..10].addUp
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Patterns: (Try clicking this one more than once...)</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
'vowels' = "aeiou"
'consonants' = "bcdfghjklmnpqrstvwxyz"

random~pattern{ in consonants, in vowels, in consonants, in consonants, in vowels }</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<hr><a name="BasicsSection"></a><h3>Section 1 - The Basics</h3>
<p>This part of a language tutorial is always tedious, so I'll try to make it quick. Swym is designed to be at least somewhat familiar to anyone who knows a C-like language, such as Java, C#, Javascript... or C itself, of course. Swym has the standard C-style comments (<code>/* */</code> and <code>//</code>), string syntax (<code>"Hello\nWorld!"</code>), arithmetic operators (<code>+ - * / % += -= *= /= %= ++ --</code>), and logical operators (<code>== != &lt; &gt; &lt;= &gt;= && || !</code>), all with the standard precedence. All the basic stuff you see in all these languages. Control expressions also resemble the ones in C - for example, <code>if(x){ return x } else { return y }</code>. And yes, you can use semicolons to separate statements - but they're mostly optional.</p>

<div class=demo>
<textarea cols=70 rows=2 onfocus='saveOriginal(this)'>
// this will output "true".
print( 4+5 == (32-5)/3 );
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<div class=aside><p>(FYI, since this is implemented in Javascript, all numbers are implemented as double-precision floats. Thus the division above is floating-point division. I haven't decided whether I want to keep this behaviour permanently.)</p></div>

<p>Yes, function calls look pretty familiar too. Calling <code>print(</code><i>whatever</i><code>)</code> will cause the specified value to be shown in the output window (without halting your program). If your program halts without doing any output at all, it'll automatically output the result of the last expression. That's what was happening with the minimalist "Hello World" above.</p>

<p>There's also the function <code>println</code>, which does the same thing as <code>print</code>, except with an added line break. Let's define our own, to see what function declarations look like:</p>

<div class=demo>
<textarea cols=70 rows=10 onfocus='saveOriginal(this)'>
Anything.'myPrintln'
{
  print(this)
  print("\n")
}

5.myPrintln // print 5

'x' = "hello"
myPrintln(x) // print hello
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=2 class=outputarea></textarea>
</div>

<p>There are two declarations here - <code>'myPrintln'</code>, and <code>'x'</code>. Notice that in order to declare something, we always write its name in single quotes. With just this one rule, you can read any Swym program and immediately figure out which bits of code are declaring which identifiers. (This can be surprisingly difficult in some languages!). Names are case sensitive.</p>

<p>Another thing to notice in this example is Swym's flexible syntax. A single-argument function call can be written function-call style (<code>myPrintln(x)</code>), or member-access style (<code>5.myPrintln</code>) with no difference in meaning. You can also mix styles in a single expression (<code>myPrintln(5.square)</code>). This distinction is entirely aesthetic. I usually find a line is more readable when written in one way or the other.<p>

<p>(Actually, that not even the whole story; the <code>~</code> (tilde) operator also denotes a function call. Its precedence is higher than the dot operator. It's intended to be used to write out a chain of function calls, without needing to worry about matching up the open and close brackets. For example, <code>print~sum~of~distinct~factors~of~x</code> is equivalent to <code>x.factors.distinct.sum.print</code>. The function <code>of</code> is a no-op: it just returns its argument unchanged. Its only purpose is to beautify expressions like this.)</p>

<p>Functions can also take more than one argument, but it would cause confusion if we allowed the same flexibility there (We can't have <code>a.given(b)</code> mean the same as <code>given(a,b)</code>)! So a function with more than one argument must be called either prefix or infix style, whichever it was declared with.</p>

<p>Also note: <code>'x' = "hello"</code> above is declaring a <em>constant</em>. You can't modify it after the initial definition. <code>x</code> will contain the value "hello", forever. Swym does have variables too, but we need to introduce a few more concepts before we get to those.</p>

<p>Finally, you'll have seen that the definition starts with the word <code>Anything</code>. That's the type signature of this function - in this case, not that interesting. <code>Anything</code> is the universal type: it matches any value at all. Note that by convention, all Swym types start with a capital letter.</p>

<p>There are 8 basic data types in Swym:
<ol>
<li>Anything (any value.)</li>
<li>Bool (the values <code>true</code> and <code>false</code>)</li>
<li>Number (values such as <code>42</code> and <code>-0.5</code>)</li>
<li>Array (values such as <code>[1,3,5,9]</code> - see <a href="#ArraysSection">Arrays</a> for more details.)</li>
<li>String (values such as <code>"Hello"</code> and <code>"\n"</code> - see <a href="#StringsSection">Strings</a>.)</li>
<li>Table (values such as <code>{"x":10, "y":15}</code> - see <a href="#TablesSection">Tables</a>.</li>
<li>Block (values such as <code>{it*it}</code> - see <a href="#FunctionsSection">Blocks</a>.)</li>
<li>Type (values such as <code>Bool</code>, or <code>String.Array</code> - types are first-class values in Swym. See <a href="#TypesSection">Types</a>.)</li>
</ol></p>

<hr><a name="ArraysSection"></a><h3>Section 2 - Arrays</h3>

<p>In Swym, an array looks much like one in Javascript. You just write a series of values, separated by commas, between square brackets. If you want you can also put a comma after the last item; or not. (Again, this is just an aesthetic choice). And naturally, <code>[]</code> is the empty array. (Or <code>[,]</code> or <code>[,,,,]</code>.)</p>

<p>Note that in Swym, square brackets <em>always</em> denote that a new array is being created. You don't write <code>array[0]</code> when you want the first element: just write <code>array.1st</code>. (and similarly <code>.2nd</code>, <code>.3rd</code>, <code>.53499th</code>, <code>.last</code>, <code>.2ndLast</code> and so on). Alternatively, to access elements of the array by index, you can write <code>array.at(idx)</code>. (The first element has index 0).</p>

<p>Arrays are arguably the most important data type in Swym - essentially, whenever you're working with a collection of multiple pieces of data, you probably want them to be in an array. To a large extent, this is because there's such a rich suite of functions for working with them. For example:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
'pairs' = [[6,2],[6,4],[9,3],[9,5],[9,1]]

pairs.sortBy{.2nd}
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>I guess I had better explain a bit there. <code>sortBy</code> is a function that takes two arguments - an array and a block - and returns the contents of the array, sorted by the results produced when applying that block to them. We haven't looked at blocks yet, but briefly, <code>{.2nd}</code> is an abbreviation for <code>'it'->{ it.2nd }</code> - in other words, it's a function that takes an array, and returns the second element of the array. Net result: the array is sorted by the second value in each pair.</p>

<p>Wanna see some of the predefined functions that work on arrays?</p>
<table>
<tr><td>foo.length</td><td>The number of values in foo.</td></tr>
<tr class=odd><td>foo.keys</td><td>A new array: all the valid indexes into foo. (for example, [1,3,5].keys is [0,1,2].)</td></tr>
<tr><td>foo.random</td><td>Any value from foo, selected at (pseudo)random.</td></tr>
<tr class=odd><td>foo.tail</td><td>A new array: all values in foo except the first.</td></tr>
<tr><td>foo.middle</td><td>A new array: all values in foo except the first and last.</td></tr>
<tr class=odd><td>foo.stem</td><td>A new array: all values in foo except the last.</td></tr>
<tr><td>foo.distinct</td><td>A new array: the values from foo, but without any duplicate values.</td></tr>
<tr class=odd><td>foo.first(n)</td><td>A new array: the first n elements of foo.</td></tr>
<tr><td>foo.last(n)</td><td>A new array: the last n elements of foo.</td></tr>
<tr class=odd><td>foo.total</td><td>(on an array of numbers) All those numbers, added together.</td></tr>
<tr><td>foo.flatten</td><td>(on an array of arrays) All those arrays, concatenated together.</td></tr>
<tr class=odd><td>foo.slice(first=i, length=n)</td><td>A new array: n elements from foo, starting at index i. (Or fewer elements, if foo is too short.)</td></tr>
<tr><td>foo.slice(first=i, last=j)</td><td>A new array: elements from foo, starting at index i and ending at index j.</td></tr>
<tr class=odd><td>foo.slice(first=i, break=j)</td><td>A new array: elements from foo, starting at index i and ending before index j.</td></tr>
<tr><td>foo.splitAt(idx)</td><td>A new array containing two halves of foo - the first containing values before index idx; and the second containing values from idx onward.</td></tr>
<tr class=odd><td>foo.splitAt(array)</td><td>A new array containing foo cut into slices - split at each index in the array.</td></tr>
<tr><td>foo.splitWhere{b}</td><td>A new array containing slices of foo, split at each value for which b returns true.</td></tr>
<tr class=odd><td>foo.firstWhere{b}</td><td>The first value in foo for which <i>b</i> returns true.</td></tr>
<tr><td>foo.lastWhere{b}</td><td>The last value in foo for which <i>b</i> returns true.</td></tr>
<tr class=odd><td>foo.where{b}</td><td>A new array: all values in foo for which <i>b</i> returns true.</td></tr>
<tr><td>foo.min</td><td>The smallest value in foo. (Or if several are equally small, the first of them.)</td></tr>
<tr class=odd><td>foo.min{b}</td><td>The value in foo for which b returns the smallest value. (Or if several are equally small, the first of them.)</td></tr>
<tr><td>foo.whereMin</td><td>A new array: all the equal-smallest values in foo.</td></tr>
<tr class=odd><td>foo.whereMin{b}</td><td>A new array: all the values in foo for which b returns the equal-smallest value.</td></tr>
<tr><td>foo.reverse</td><td>A new array: the contents of foo, in reversed order.</td></tr>
<tr class=odd><td>foo.shuffle</td><td>A new array: the contents of foo, in a random order.</td></tr>
<tr><td>foo.sort</td><td>A new array: the contents of foo, in ascending order.</td></tr>
<tr class=odd><td>foo.sortBy{b}</td><td>A new array: the contents of foo, sorted by the values returned by <i>b</i>.</td></tr>
<tr><td>foo.each{b}</td><td>A new array: the result of calling b on each element.</td></tr>
<tr class=odd><td>foo.some{b}</td><td>True if b returns true for some element; otherwise, false.</td></tr>
<tr><td>foo.all{b}</td><td>True if b returns true for all elements; otherwise, false.</td></tr>
</table>

<p>Heck, I'm just scratching the surface here. Check out the Swym standard library, <a href="SwymViewStdlyb.html">Stdlyb</a>, for full details and implementations.</p>

<hr><a name="StringsSection"></a><h3>Section 3 - Strings</h3>

<p>Strings are a special case of arrays. Any function that operates on a generic array can also operate on strings:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
"Hello".distinct.reverse
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>All right, you may ask - what do you get if you take the <code>.1st</code> element of a string? Well, it's another string! Swym has no separate "character" type; it's strings all the way down. Every string is an array of strings, and each of those is an array of strings, and so on. Don't worry, you'll be fine - just take care when doing depth-first searches.</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
"Hello".1st.1st.1st
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>Swym supports string interpolation, as seen in Perl or Ruby: when you write <code>$name</code> in a string, you're inserting the contents of the value called <code>name</code> at that point. If you actually want a $ sign in your string, use <code>\$</code>.

<p>Unlike Perl or Ruby, however, Swym also lets you write <code>$foo.bar</code> to call a postfix-style function within a string - or <code>$(</code><i>whatever</i><code>)</code> to run some arbitrary code. The latter is also useful to precisely mark the end of the interpolated section - for example, without it you couldn't insert a value that's immediately followed by a letter. <code>"You're on the $(floor)th floor."</code>.</p>

<p>If you're printing values for debugging purposes, you may want to use the debug tostring operator <code>$$</code>, instead of the terse tostring operator <code>$</code>. As far as possible, the debug operator generates Swym source code that would construct the given value - whereas the terse operator generates shorter output. For example:

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
'x' = "Hello!"

println( "Normal: $x" )
println( "Debug: $$x" )
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>By the way, I'm calling them operators because they're not limited to string interpolations. $ and $$ are standalone prefix operators that you can use anywhere in your program:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
'x' = 20

$(x*x)
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>By the way, notice that when Swym automatically outputs values, as above, it uses the debug tostring mode. Whereas if you print something using the <code>print</code> function, it will use the terse tostring operator - that's because print is, in fact, defined in the Swym standard library as:</p>

<p><code>Anything.'print' = output($this)</code></p>

<p>...where <code>output</code> is a built-in native function that takes a string (but only a string) and simply outputs it. And while we're on the subject, here's another useful function to know about, from the Swym standard library:</p>

<p><code>Anything.'trace' = output("$$this\n")</code></p>

<p>That's the debug version of println.</p>

<hr><a name="FunctionsSection"></a><h3>Section 4 - Functions and Blocks</h3>

<p>Take it away, maestro...</p>

<div class=demo>
<textarea cols=70 rows=13 onfocus='saveOriginal(this)'>
Int.'bottles' = case(this)
{
  0 => "no more bottles",
  1 => "1 bottle",
  else => "$this bottles"
}

forEach[99..1]
{
  println("$it.bottles of beer on the wall, $it.bottles of beer!");
  println("You take one down, pass it around, $((it-1).bottles) of beer on the wall.");
}</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=13 class=outputarea></textarea>
</div>

<p>This example will hopefully give you a bit more of a feel for the language. I won't explain every detail for now, but the basic logic should be clear enough: first we're defining a function called <code>bottles</code>, which takes an <code>Int</code> as a parameter (implicitly named <code>this</code>), and uses the function <code>case</code> to choose one of three possible templates to display that number of bottles. Then, to print each verse, we count down from 99 to 1, calling <code>it.bottles</code> each time to fill in the appropriate numbers of bottles.</p>

<p>All right, so where did "it" come from? I guess it's high time we talked about blocks. We've used several of them in the last few examples, without really explaining them. Blocks are Swym's lambda functions - in other words, first-class function values.</p>

<p>The notation for declaring blocks is very minimalist: just write any expression in curly brackets. A block declared this way will implicitly take one argument, called <code>it</code>, and return the result of evaluating the expression. So <code>{it*2}</code>, for example, is a function that just doubles the number you pass to it.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
44.{it*2}
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>To store a block for later use, you can simply assign it to a variable - like any other value.</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
'myblock' = {it/2}

44.do(myblock)
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Oh, and notice the last line there - writing <code>44.myblock</code> is not valid! We haven't declared a function named <code>myblock</code> here - we've just named a value. To actually do something, we need to call a function - in this case, the <code>do</code> function. In Swym, functions have their own namespace, separate from values. In other words, it's fine to define a value named <code>half</code>, and a function named <code>half</code>: they'll coexist peacefully.</p>

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
Number.'half' = this/2
'half' = 0.5

half.half
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>This system has some interesting consequences - the biggest one being that <em>you cannot directly refer to a function</em>, except by calling it. Blocks are first-class values that can be passed as arguments, returned, stored, printed, etc; but functions cannot. The only thing you can do with functions is to call them. This is pretty unusual in a functional language, but as it turns out, blocks are plenty powerful enough. If you want pass a function (say, <code>println</code>) as an argument to another function, you would instead define a block which <em>calls</em> your function (say, <code>{.println}</code>), and pass that.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[1,3,5,9].each{.println}
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=5 class=outputarea></textarea>
</div>

<p>As you can perhaps see, although Swym could certainly (semantically speaking) be classed as a functional language, it gently discourages the kind of mind-bogglingly abstract function-munging that sometimes goes on in languages like Haskell.</p>

<hr><a name="MultivalueSection"></a><h3>Section 4 - Multi-values</h3>

<p>And now for something completely different (different from every other language, that is). In most languages, an expression must return one and only one value. In Swym, an expression can return <em>several</em> values!</p>
<p>So, er, what does that mean? Well, one common use for it is to fill in the contents of an array. If you write a multi-valued expression in an array, the result will be an array with <em>all</em> those values inserted at that position.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[10, 1..4, 0, 100, 1<..<8]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>This is demonstrating two of the simplest multi-value operators.</p>
<!--p>The <code>Â±</code> operator returns two values: a + b, then a - b. (Or the left hand side can be omitted - so it will just return b, then -b). And, er, yes... that's not an ascii symbol. I'm not entirely comfortable with this, but it has survived my numerous attempts to replace it. Bottom line: there's just no better way to write plus-or-minus. And really, it's not <em>that</em> awkward. You can type it with Alt-241, which makes a nice easy-to-remember triangle pattern on the numeric keypad. And if all else fails, you can even use the pure ascii version, <code>+_</code>. Nevertheless, this is probably one of my more controversial design decisions in Swym. I'll be interested to see how reliably it can be displayed, and what people make of it.</p-->
<p>The <code>..</code> operator returns a sequence of integers - starting with the left hand one, and ending with the right hand one. The sequence can be ascending or descending, and will include both endpoints. If you want a sequence that excludes one or both endpoints, and/or enforces an ascending or descending order, there are some related operators: <code>..&lt;</code> for example, which will exclude the right hand number - and also the left hand one, if it's greater than or equal to the right hand side. So <code>1..&lt;0</code>, for example, won't return any values at all. Other operators in the family are <code>..&gt; &lt;.. &gt;.. &lt;..&lt; &gt;..&gt;</code>.

<p>And of course, we're already familiar with the simplest multi-value operator: the <code>,</code> operator just returns the value(s) from its left hand side, followed by the value(s) from its right hand side.</p>

<p>One particularly useful way of producing multiple values is the <code>each</code> function. (That's the one-argument form - not the two-argument form that we've already seen.) <code>each</code> takes a list, and literally returns each element of that list. It's the inverse of the array construction <code>[]</code> operator. For example:</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
Int.'nontrivialDivisors' = [1<..this/2].where{ this%it == 0 }

Int.'divisors' = [1, each(.nontrivialDivisors), this];

16.divisors</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>This is a little more involved, so let's go through it step by step.</p>
<p>The first line is a function that takes a number, and generates a list of its nontrivial divisors (i.e. the numbers it's divisible by, except for 1 and itself). So for example, <code>nontrivialDivisors~of~16</code> would return <code>[2,4,8]</code>. The function works by first generating an array <code>[1&lt;..this/2]</code>, which contains every positive integer greater than 1, up to and including half of the number in question (a little optimization there). Then, it calls <code>where</code> to discard those which don't divide into the first number with remainder zero.</p>

<p>In particular, notice the code <code>this%it</code> - where <code>this</code> is the number we're generating the divisors for, and <code>it</code> is the list element we want to test.</p>

<p>The second line is a function that generates a list of all divisors for a number, both trivial and nontrivial. It does this by simply constructing a list containing 1, then (literally) each nontrivial divisor, and then the number itself. And finally, the third line calls <code>divisors</code> to generate all the numbers 16 is divisible by.</p>

<p>So, we've seen how a multi-value expression behaves within square brackets. Let's have a look at how they interact with other expressions. For example:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[ 10 + (1..6) ]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Yes, writing 10 + (1..6) is like writing 10+1, 10+2, 10+3, 10+4, 10+5, 10+6. Basically, the whole expression <code>10+(<i>something</i>)</code> is being evaluated once for each (<i>something</i>). If there are two or more multi-values, we run the expression once for each <em>pair</em> of values - each value on the left gets combined with each value on the right:

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[ (1..5) * (1,10,100) ]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Functions and string interpolations also work this way. For example, here we call <code>println</code> repeatedly:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
println("println has been called $(1..6) time(s)");</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=7 class=outputarea></textarea>
</div>

<p>There's an important corollary to this: when you're writing code for the body of a function, the function parameters it receives are guaranteed to be single values. If someone does call your function with a multivalue, the function body will just run multiple times.<p>

<p>Oh, and there's one function which gets called this way an awful lot. We saw it in the bottles of beer example - it's called <code>for</code>.</p>

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
for(1..6)
{
  output("blah ");
}
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>The last concept I want to introduce here is called <i>no values</i>. It follows fairly obviously from the features I just explained: if an expression can evaluate to more than one value, naturally it can also evaluate to <em>less</em> than one. <code>each[5,6,7]</code> returns three values, while <code>each[]</code> returns no values.</p>

<p>Similarly, if you write <code>print(each[5,6,7])</code>, the print function gets called three times. And if you write <code>print(each[])</code>, the print function doesn't get called at all.</p>

<p>Enter the operator <code>?</code>. It takes any number of values, and drops any that are <code>false</code> or <code>null</code>. So <code>null?</code> will return zero values, just like <code>each[]</code>.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
(true, false, 1, 0, null) ?</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>This turns out to be great for aborting a series of function calls that might fail at any point:</p>

<p><code>ApronPocket: [bob?.mother?.apron?.pocket?];</code></p>

<p>That is to say: if bob exists, get his mother; if his mother exists, get her apron; if her apron exists, get its pocket. But if any of these is <code>null</code>, don't call any more functions: ApronPocket will just become <code>[]</code>.</p>

<p>In fact, <code>?</code> acts as the language's primitive building block for all conditionals. The <code>if</code> function can be trivially defined using <code>?</code>:</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
myif(Value)(.then:Function): for(this?){ then() };

x: 2;
myif(x > 0){ output("x > 0 "); };
myif(x &lt; 2){ output("x &lt; 2 "); };</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Ta-daa! In Swym, <code>if</code> is just a normal function. It takes a value and a function, and calls the function if and only if the value is truthy.</p>

<p>Note that if the value is falsy, <code>if</code> returns zero values. This is pretty handy, as it turns out, because we can detect the difference with...</p>

<div class=demo>
<textarea cols=70 rows=7 onfocus='saveOriginal(this)'>
myif(Value)(.then:Function): for(this?){ then() };

x: 1;
myif(x > 1)
{ print("x > 1"); }
else
{ print("x &lt;= 1"); }</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>After all, how silly would it look to have an "if" without allowing an "else"?</p>

<p><code>else</code> is a keyword. (One of a very select set, in fact, because the language only has three keywords - <code>is</code>, <code>else</code>, and <code>etc</code>). On its left hand side, <code>else</code> takes any number of values. If there's one or more of them, it returns those values unchanged. If there are zero values, it evaluates and returns its right hand side instead.</p>

<p>(As is probably becoming clear, Swym is a C-like language that's built out of lego bricks.)</p>

<p>One last thing to note - <code>a? else{b}</code> is a handy way to express a "fallback" in the event that <code>a</code> is null. But there's no easy way to emulate an a?b:c operator this way. You'll just have to say <code>if(a){b}else{c}</code>.

<hr><a name="VariablesSection"></a><h3>Section 8 - Variables and cells</h3>
<p>Ok - on to Swym's support for mutable data. As we already established, most of the time when you declare something in Swym, it's a constant. Here's an example of declaring a variable, modifying it, and reading from it:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
'x' = Int.var=5
x.set = x*2
x.set -= 3
print(x.get)
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p></p>

<p>Also like C, variables in Swym get passed by value. In other words, when you pass a variable into a function, its "variableness" will be stripped off. This prevents functions from unexpectedly modifying your variables. To prevent this behaviour, you can wrap the variable using the <code>ref</code> function.</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
Int.Ref.'increment' = .value+=1
Int.Var 'x' = 5

x.ref.increment
print(x)
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>



<hr><a name="EtcSection"></a><h3>Section 5 - The Etc keyword</h3>
<p>I think <code>etc</code> is probably the part of Swym that I'm most proud of. It's the ultimate embodiment of language's design philosophy: code readability, at the cost of all else. Writing <code>etc</code> in an expression is your way of telling the compiler "...and so on in the obvious way. You figure it out". Let's have a look:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Array.'addUp' = .1st + .2nd + etc

[1..10].addUp
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>There isn't all that much for the compiler to figure out, here... but we can already start to get a hint of how powerful this concept can be. The <code>etc</code> keyword must appear immediately after an infix operator, and it searches the surrounding code for a chain of instances of that operator, and the arguments they take. In this case it sees the <code>+</code> operator, and two arguments: <code>.1st</code> and <code>.2nd</code>. From these it can extrapolate <code>.3rd</code>, <code>.4th</code> and so on, stopping (it helpfully deduces) when the end of the list is reached. Let's see another example:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Array.'byPairs' = [[.1st, .2nd], [.3rd, .4th], etc]

byPairs[1..10]
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Now we're making a sequence of <code>,</code> operators, and we have two terms to extrapolate from - <code>[.1st, .2nd]</code> and <code>[.3rd, .4th]</code>. What's the difference between these two expressions? Well, <code>.1st</code> has been replaced with <code>.3rd</code>, and <code>.2nd</code> has been replaced with <code>.4th</code>. The compiler considers each of these differences independently. So for the first case it will deduce the sequence <code>.1st .3rd .5th .7th...</code>, and for the second, <code>.2nd .4th .6th .8th...</code>.</p>

<p>And, for those who are wondering: yes, 2-4-6-8 is the default, but you can get it to understand 2-4-8-16 if you give enough examples.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[2,4,8,etc..<10000]
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Also note the halt condition, which - of course - is reminiscent of the 1..&lt;10 notation we saw earlier. An <code>etc..&lt;</code> expression will terminate as soon as it sees a term that's greater than the termination value. Note that while the left hand side of an etc expression is handled at compile time, the termination value is determined at runtime, so you can put a runtime variable there if you want. And as you'd expect, there's a related family: <code>etc..&lt;= etc..&gt; etc..&gt;=</code>. </p>

<p>We can use this to decompose a number into powers of two -</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Int.'toBits'
{
  Int:'current' = this
  
  [1,2,4,etc..<=this].reverse.where{<=current} 'bit'->
  {
    current = current - bit
    bit
  }
}

19.toBits
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>The compiler always assumes that each entry in the sequence follows directly on from the previous one. So if you'd like your etc sequence to alternate in some way, you'll need to bracket the expressions. let the compiler deduce how each <em>group</em> of terms follows on from the previous <em>group</em>.

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
'interleave'('a')('b') = [ (a.1st, b.1st), (a.2nd, b.2nd), etc]

interleave[1..9][100,200,etc..900]
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>In the end, the compiler processes <code>interleave</code> in almost exactly the same way as <code>byPairs</code> - comparing the expression <code>(a.1st, b.1st)</code> with the expression <code>(a.2nd, b.2nd)</code>.</p>

<p>Here's a quick demonstration of how to define your own <code>each</code> function. (This is not actually how the built-in <code>each</code> function is defined, but only for efficiency reasons.) Look, there's nothing magical about it! (at least, no more magic than the rest of the language...)</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Array.'myeach' = .1st, .2nd, etc

10 + myeach[1..5]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=5 class=outputarea></textarea>
</div>

<p>And this etc concept keeps on surprising me - every time I work with it, I find something new it can do. Very cool. Here's a particularly elegant one:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Array.'transpose' = [[.each.1st], [.each.2nd], etc]

transpose[[10..15],[20..25],[30..35]]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=2 class=outputarea></textarea>
</div>

<p>And another:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
1/2 + 2/4 + 3/8 + etc</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div><br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>I should point out here that I've capped the number of iterations to avoid having infinite loops in cases like this. At the moment, an <code>etc</code> expression cannot perform more than 1000 iterations. This won't be a permanent limit - just until the compiler can be made a little smarter about detecting loop termination conditions.</p>

<hr><a name="PatternsSection"></a><h3>Section 6 - Introducing Patterns</h3>
<p>The last big concept in Swym that I haven't covered yet is the Pattern. We've seen a few already - here are some of the predefined patterns that Swym offers.</p>

<!--div class=floatbox><image src="plaid.jpg"><br><center><small><i>Not that kind of pattern.</i></small></center></div-->
<a name="patternlist"></a>
<table>
<tr class=odd><td>Int</td><td>Any whole number.</td></tr>
<tr><td>Positive</td><td>Any number greater than zero.</td></tr>
<tr class=odd><td>Natural</td><td>Any whole number greater than or equal to zero.</td></tr>
<tr><td>Num</td><td>Any number.</td></tr>
<tr class=odd><td>Pattern</td><td>Any pattern (function or list).</td></tr>
<tr><td>String</td><td>Any string. (a list that contains only characters.)</td></tr>
<tr class=odd><td>Function</td><td>Any function.</td></tr>
<tr><td>List</td><td>Any list.</td></tr>
<tr class=odd><td>Bool</td><td>The value true or false.</td></tr>
<tr><td>Value</td><td>Any number, list, pattern, function... anything. This is the most general pattern possible.</td></tr>
</table>

<p>That's right - the types we've been using are patterns. You can think of a pattern, in general, as a (potentially infinite) set of possible values. The key feature that patterns have is the ability to test whether they contain a given value, using the <code>is</code> operator:</p>

<div class=demo>
<textarea cols=70 rows=6 onfocus='saveOriginal(this)'>
print( 4 is Num ) // true, 4 is a number

DivisorOf16: [1,2,4,8,16];
print( DivisorOf16 is List ) // true, it is a list

print( 4 is DivisorOf16 ) // also true
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>That last line was there to wake you up. A list is a kind of pattern! Specifically, it's a pattern that contains a very limited set of values - the elements of that list. Check out how <code>Bool</code> is defined, for example:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
Bool</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Having said that... what are the more general patterns, like Value or String? Surely they can't be lists of all possible values...?</p>

<div class=demo>
<textarea cols=70 rows=8 onfocus='saveOriginal(this)'>
Even: {it%2 == 0};
print(5 is Even); // false, 5 is not an even number

UnderTen: {it &lt; 10};
print(5 is UnderTen); // true, 5 is less than ten

myValue: {true}; // let's define our own version of Value
print(5 is myValue); // true, everything is a Value</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>Well, hey - a function is also a kind of pattern! Specifically, a function is a pattern that contains all values for which it returns a truthy value.</p>

<p>We're seeing something new here: these functions are being stored under ordinary variable names. You may remember, back when I defined <a href="#myfor">myfor</a>, that I said functions have their own namespace - and that if I had called the function <code>f</code> instead of <code>.f</code>, that function would not have been callable. Well, that's what is happening here. UnderTen is a function that has been 'disarmed'. By storing it under a normal variable name, we've made it behave like a normal value - you can pass it around, and test it with <code>is</code>, but it cannot be called unless you first copy it into a <code>.foo</code> variable. (In fact, the easiest way is to call a function that will do that for you: <code>for(&nbsp;x,&nbsp;UnderTen&nbsp;)</code>).</p>

<p>Let's try defining a pattern that's more than just a toy example.</p>

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
Int.Divisor: [1..this].Where{this%it == 0};
Prime: {.Divisor == [1,this]};

[1..50].Where(Prime)
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Let's see how many surprises we can pack into this section. Remember the <code>Where</code> function we saw earlier, that filters a list? Well, its argument is actually just a pattern:</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
[1..10,10..1,1..10].Where[3,5]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>As is probably pretty obvious at this point, 'patterns' correspond to sets in set theory. <code>Where</code> is intersection, <code>[]</code> the empty set, and <code>Value</code> the universal set. The operator <code>|</code> serves as set union, and (equivalently) list concatenation. And inversion? Well, that would be the <code>Non</code> function. But hey, why don't we implement our own?</p>

<div class=demo>
<textarea cols=70 rows=7 onfocus='saveOriginal(this)'>
MyNon(Pattern):
{
  {!(it is this)} // look, it's a function that returns a function!
}

print(5.5 is MyNon(Int)); // true, it's not an integer
print(6 is MyNon(Int)); // false, it's an integer</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=2 class=outputarea></textarea>
</div>

<p>You can even implement Bertrand Russell's favourite paradox if you want:</p>

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
PatternNotContainingItself: Non{it is it};

print(Value is PatternNotContainingItself); // false
print([1,2,3,4] is PatternNotContainingItself); // true</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=2 class=outputarea></textarea>
</div>

<div class=aside><p>(Pop quiz: apart from Value, my <a href="#patternlist">introductory list</a> contains two other patterns that aren't described by PatternNotContainingItself. Can you name them?)</p></div>

<p>And naturally, there's no way to answer whether <code>PatternNotContainingItself is PatternNotContainingItself</code>. (In fact, on the current implementation that'll cause a stack overflow).</p>

<p>So: that's the 'what' of patterns, in a nutshell. Now I guess I'd better answer the 'why': what are these things good for? Why are they in the language? Why conflate lists with functions and treat them both as sets?</p>

<p>To start answering that question, here's another example.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
each-Pair-of-Bool
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=4 class=outputarea></textarea>
</div>

<p>The Pair function, applied to a pattern, is a simple enough concept - it lets you confirm that <code>[4,5] is Pair-of-Int</code>, for example.</p>

<p>But, as I played with this concept - and others like it that we'll see in a moment - I realized it ought to be more powerful. There are lots of situations where it's really useful to be able to iterate though every possible value of a given type; and if you use Pair on such a type, it would make sense to allow you iterate through every possible pair of those values.</p>

<p>I soon realized that these 'enumerable types' were essentially the same as lists - and there were plenty of situations where I wanted to use a list function on an enumerable type, or vice versa, so I was having to convert data from one format to the other. Really clunky.</p>

<p>So I unified them. All enumerable types are lists. All lists are enumerable types. And if you call Pair on a list (rather than just a pattern), it returns another list: all possible Pairs of elements of your list.</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
Pair-of-Bool
</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Internally, however, this thing is smarter than your average list - it doesn't just blindly generate the list of pairs and then try to match potential candidates against every one of the possible pairs. Enumeration happens only on demand; and testing whether a given list is a Pair-of-Bool would use a completely different code-path.</p>

<p>Here are some more functions that produce these "smart lists":</p>

<table>
<tr class=odd><td>List.Segment</td><td>All the different contiguous segments that can be taken from this list.</td></tr>
<tr><td>List.Prefix</td><td>All the segments that start from the first element.</td></tr>
<tr class=odd><td>List.Suffix</td><td>All the segments that end with the last element.</td></tr>
<tr><td>List.Filter</td><td>All the different ways you could drop elements from this list.</td></tr>
<tr class=odd><td>List.Permutation</td><td>All the different ways to reorder this list.</td></tr>
<tr><td>List.Partition</td><td>All the ways to slice this list into (nonempty) pieces.</td></tr>
<tr class=odd><td>P.Pair</td><td>All the possible lists that contain two P's.</td></tr>
<tr><td>Struct{P1, P2}</td><td>A generalization of Pair: all the possible lists that contain a P1, then a P2 - or whatever other sequence you specify.</td></tr>
</table>

<p>These things are really nice to work with. Who likes anagrams?</p>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
random-Permutation-of("Hello World!")</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>(As you may recall, the <code>random</code> function just selects one random element from a list.)</p>

<p>Alternatively, we can generate new nonsense words:</p>

<div class=demo>
<textarea cols=70 rows=4 onfocus='saveOriginal(this)'>
Vowel: "aeiou"
Consonant: "bcdfghjklmnpqrstvwxyz"

random-Struct{ Consonant, Vowel, Consonant, Vowel }</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>And usual, the next step in this process is to start defining our own! The simplest way to create a lazy-evaluated list is the <code>LazyList</code> function. For example, let's define our own version of the Prefix function - which takes a list, and returns all the ways you could truncate the list.</p>

<div class=demo>
<textarea cols=70 rows=6 onfocus='saveOriginal(this)'>
List.MyPrefix: LazyList(.length)
{
  [this.at(0..it)]
}

each-MyPrefix-of[100..106]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=7 class=outputarea></textarea>
</div>

<p>The LazyList function takes two arguments: the length of the list we're generating, and a function that generates elements of that list, when given their index.</p>

<p>It also has an optional third argument: a <em>pattern</em> that we can use to quickly decide whether a value is in the list. This is just an optimization - if you don't provide one, testing it will still work, but it'll be much slower. It'll search through the list, checking each element to see whether it matches. The whole point of using a LazyList, though, is that it's (potentially) an incredibly long list with a definite pattern to it. Let's try defining that Pair function.</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
List.MyPair: LazyList(.length * .length)
{ [ this.at(it%this.length), this.at-floor(it/this.length) ] }
{ it is List && .length == 2 && .1st is this && .2nd is this; };

each( MyPair-of[100..106].Where-MyPair-of[104..109] )</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=9 class=outputarea></textarea>
</div>

<!--p>Let's try something trickier - the Partitioning function.</p>

<div class=demo>
<textarea cols=70 rows=9 onfocus='saveOriginal(this)'>
List.MyPartitioning: LazyList(2.pow(.length-1))
{
  for[this.Cell.1st, this.Cell.Tail.Filter.at(it).each]
{
  [ ([.1st..&lt;.2nd], [.2nd..&lt;.3rd], etc), [.last..this.last]]
}
};

each-MyPartitioning-of[100..106]</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=7 class=outputarea></textarea>
</div-->

<hr><a name="FutureSection"></a><h3>Section 7 - Future Development</h3>

<p>This section is just to show off some more features that are more or less working, but I'm not satisfied with their current design.</p>

<h4>Quantifiers:</h4>

<div class=demo>
<textarea cols=70 rows=7 onfocus='saveOriginal(this)'>
A:[1..10];
B:[5..9];

if(/ some(A) > every(B) )
{
   print("Yes, there's an A that is greater than every B");
}</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Quantifiers allow you to say what you mean using a convenient, familiar english concept. They're currently implemented as a special kind of multi-value. So you can think of the functions <code>.some</code> and <code>.every</code> (and their less positive brothers <code>.no</code> and <code>.notevery</code>) as being strange cousins to the <code>.each</code> function.</p>

<p>Basically, this expression some(A) > every(B) is getting executed once for every possible pairing of A and B values - but stopping when a match is found. Note also that lexical order matters - so <code>some(A) == every(B)</code> is quite different from <code>every(B) == some(A)</code>. (The first one checks whether there's just a <em>single</em> value in A that's equal to <code>all</code> the values in B. The second one checks whether each of the values in B is equal to some value - but not necessarily all the same value - in A).</p>

<p>In an ideal world, I'd like to allow <code>.some</code> (but not the others) to bind the value it has matched: <code>if(/test( result:some(A) )){ ...do something with result... }</code>. I also want to find a way to get rid of the resolve operator, <code>/</code> - that's how you convert these multi-values into single boolean results. But it feels clumsy to me - I want them to be auto-resolved reliably enough that you almost never need to use it. I just haven't found the correct rule for when to do it.</p>

<h4>Cells:</h4>

<div class=demo>
<textarea cols=70 rows=1 onfocus='saveOriginal(this)'>
Cell[1,2,4,etc..<500].Where{it > .index*10}</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Cells are an amazingly useful and natural concept but, again, I'm not 100% happy with them at the moment. Essentially, a cell is an element of a list that has added metadata: it knows what list it's from, and which index it was at within that list.</p>

<p>To get started, the Cell function is used to convert any list into a list of cells. The cells are the same as the elements of the original list, except that they respond to three extra functions: <code>.sourceList</code> to get the original list, <code>.index</code> to get this cell's index within that list, and <code>.cellValue</code> to strip away this metadata and just return the original value.</p>

<p>So far, this probably sounds moderately useful, but a little clunky. Why do we use the Cell function - isn't that just a needless extra step? Why can't this information come along for free, <em>every</em> time we get an element from a list? Well, actually, this explicit call provides one crucial benefit: we make it possible for the programmer to specify exactly <em>which</em> source list he was interested in. In other words, it becomes possible to make a list that contains cells from <em>another list</em>.</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
X:[101,107,112,116,etc..>100];

Y:Cell(X).Where{it > 115};

Y.Each{.index}</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>Here, the function Where scans through the list we give it, selects the values that are greater than 115, and uses them to create a list Y. But since the input list is <code>Cell(X)</code>, Y is actually a list of cells - cells whose source list is list X. Which means that when we tell the Each function to get the index of each of them, we see their index <em>within the list X</em>, not their index in the list Y.</p>

<p>I said that cells behave the same as the value they're based on... but there is one more difference:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
List.MyMiddle: [1st(.Cell) <..< last(.Cell)];

MyMiddle("Hello World");</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>When you use a range operator on a pair of cells, you're not getting a numeric range: you're getting a range of cells from the source list. This makes it amazingly easy and natural to manipulate slices of a list, and do all kinds of useful tricks.</p>

<p>Finally, I should point out you're not limited to calling the standard <code>.sourceList</code> and <code>.index</code> functions. If you want, you can define your own functions that operate on cells:</p>

<div class=demo>
<textarea cols=70 rows=3 onfocus='saveOriginal(this)'>
Cell.After: [it <.. last-Cell-of(.sourceList)];

After-3rd-Cell-of("Hello World");</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>So, yeah, it's all really cool stuff... but the current implementation has problems. If you filter a list of cells (as we saw above), and then you use MyMiddle on the filtered list, the result will have lost its original cell metadata. MyMiddle calls Cell internally, so the cells it returns are always sourced to the <em>filtered</em> list! I haven't entirely figured out what I want to do about this, but I think I want some lexical scoping here. Each block of code can only have one cell list, and if you call .Cell on a list, then that's the cell list you're going to use. Any use of .index - or any other function that takes a Cell as its argument - will implicitly select that cell list.</p>

<h4>Vars:</h4>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
x: Int.var = 5;
print(x);

x = 7;
print(x);</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=3 class=outputarea></textarea>
</div>

<p>Eagle eyed readers may have noticed that this is the first time I've used an assignment operator in this entire tutorial. Swym is powerful enough that mutable data is often unnecessary, but I'm a pragmatist: when you need it, you need it. So I added support for opt-in mutable data.</p>

<p>The question is, how should it work? Under the current implementation, it's a form of metadata, much like the cells we just saw. As you can see, you create new variables with the <code>.var</code> function. It takes one argument, a pattern: in this case, <code>Int</code>. So this variable can only contain integer values. Initially, we assign it the value <code>5</code>, which means <code>x</code> can be treated almost exactly like the value <code>5</code>, but with one extra feature: you can assign it new values with the <code>=</code> operator (and others like <code>+=</code> or <code>--</code>). ()</p>

<p>This seems like a pretty nice model. For example, it means you can create a list of variables, generate a new list containing some of those variables, and use that to modify the original list.</p>

<div class=demo>
<textarea cols=70 rows=5 onfocus='saveOriginal(this)'>
MyList:[ for(1..10){ Value.var = it~ } ];

MyList.Where{it%2 == 0}.each += 100;

output(MyList)</textarea>
<div class=control><input type=button class=control value="+/-" onclick='doResize(this.parentNode);'>
<input type=button class=control value="Revert" onclick='doRevert(this.parentNode);'></div>
<br>
<input type=button value=Run style="vertical-align: top;" onclick='runDemo(this.parentNode);'>
<textarea cols=70 rows=1 class=outputarea></textarea>
</div>

<p>In contrast to the other features in this section, I haven't really found a reason to call this "flawed" - it's just an area for future development. Sometimes, Saying What You Mean has to involve mutable data, because that's just What You Mean.</p>

<p>Ok, well... th-th-that's all I have for now, folks! Hope you enjoyed it!</p>

</body>
</html>
